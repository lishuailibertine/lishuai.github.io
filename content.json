[{"title":"区块链bip32、bip44、bip39介绍","date":"2020-04-30T02:05:00.000Z","path":"2020/04/30/区块链bip32、bip44、bip39介绍/","text":"1. 账户体系介绍 在区块链交易中会涉及到账户，这个账户相当于你的银行卡卡号一样，通过这个账户你可以很方便的去接收发送代币。像银行卡一样你也可以拥有许多账户。那么这个账户是怎么产生的呢?注: 大致为 私钥-&gt;椭圆曲线算法-&gt;公钥-&gt;hash-&gt;地址 2. bip32 补充说明下 BIP: Bitcoin Improvement Proposals 比特币改进建议, bip32是第32个改进建议。bip32生成私钥的过程是一个分层推导的过程。 一句话概括下BIP32就是：为了避免管理一堆私钥的麻烦提出的分层推导方案。 2.1 主私钥主私钥 它是由一个随机数种子根据hmac_sha512生成64字节长度的主私钥,主私钥前32个字节作为私钥将要作为下次生成子私钥的输入参数,后32个字节作为主链编码ChainCode。1234NSData *masterPriKey = [DeterministicKey masterPriKeyForSeed:seed forKey:[@&quot;xxx&quot; dataUsingEncoding:NSUTF8StringEncoding]];Pri:[masterPriKey subdataWithRange:NSMakeRange(0, 32)]ChainCode:[masterPriKey subdataWithRange:NSMakeRange(32, 32)] 2.2 推导子私钥推导子私钥 衍生推导的方案其实有两个：一个用父私钥推导（称为强化衍生方程），一个用父公钥推导。通过子秘钥向下一层（深度扩展）可以无限生成私钥。 3. bip44 指定了推导结构:m / purpose’ / coin’ / account’ / change / address_index; 一句话概括下BIP44就是：给BIP32的分层路径定义规范 m 是固定的; purpose 是固定的，值为44; coin 每条公链都不相同,可在这里查看; account 代表这个币的账户索引，从0开始; change 常量0用于外部链一般用于转账收款;常量1用于内部链一般用于找零为不可见地址; address_index 地址索引从0开始，代表生成第几个地址,官方建议，每个account下的address_index不要超过20; 3. bip39 用户只需要记住自己的私钥就能拿到自己的资产了。但是私钥那么长我记不住怎么办？这时候bip39 提案就来了，用户不用记住一大串的16进制数据了，只需要很短的随机数种子或者是助记词就可以拿到自己的资产; 文章只是简单的描述下几个提案的区别，更详细的内容可以查看知乎上的这篇文章讲的很好","tags":[{"name":"工作中的点滴","slug":"工作中的点滴","permalink":"http://yoursite.com/tags/工作中的点滴/"}]},{"title":"JS与原生iOS通信","date":"2019-07-11T05:40:46.000Z","path":"2019/07/11/JS与原生iOS通信/","text":"通信组件的由来随着h5在原生页面中用到的越来越平凡(市面上流行的APP都可以看到它的身影 ),在我们用h5去与原生通信的时，h5会有许多需要原生提供业务功能的地方；这时候如果是几个简单的功能，很可能我们就会把业务处理放到webview中去做处理了，但是真实的情况并不是这样，一个项目大概会有至少几十个调用原生功能的地方，这时候你那么去做势必会让类负担很重，并且维护的成本也非常的高; 我们需要的一个管理这些功能的地方；写这个组件希望它可以达到一些目的:让h5的开发人员使用起来很方便；让我们原生开发的人员不需要关心那些琐碎的桥接等等；维护起来很方便; 如果生产中出现问题它可以做到容错不至于APP无法使用,并把无法通信的原因告诉h5; 通信组件如何去设计1、我想让它不仅能在UIWebview内核中使用，它还可以在最新的内核WKwebview中使用;2、需要一个管理JS上下文的类，这个类与webview打交道，除了注册我们业务层需要的功能，它还负责把h5的消息传递给原生; 通信组件通过时序图去说明 通信组件在h5端如何使用举例: 调用原生摄像头,(callCamera)123456789101112//native:挂载在window上的对象(详情请看中间件)，主要提供callMessage给h5调用//param1:调用的原生对应的功能(声明的方法)//param2:调用原生对应功能的入参(任意类型)//param3:原生返回给h5的callback结果native.callMessage(\"callCamera\",&#123;\"\"&#125;,function callback(argument) &#123; alert(argument);&#125;); 举例:其他功能native.callMessage(\"功能2\",&#123;\"\"&#125;,function callback(argument) &#123; console.log(原生返回的消息)；&#125;); 中间件介绍(NativeJS)主要担任的职责:1、提供轻便易用的接口给H5使用;2、整合兼容UIWebview与WKWebview内核;3、其他 通信组件在原生端如何使用12345//UIWebview使用[self.jsContextManage captureJSContextBrigeWithType:SLJSContextManageType_UIWebview jsServer:@protocol(SLJSApi) nativeImp:nativeApi];//WKWebview使用[self.jsContextManage captureJSContextBrigeWithType:SLJSContextManageType_WKWebview jsServer:@protocol(SLJSApi) nativeImp:nativeApi];","tags":[{"name":"工作中的点滴","slug":"工作中的点滴","permalink":"http://yoursite.com/tags/工作中的点滴/"}]},{"title":"设计一个换肤工具","date":"2018-02-28T07:11:27.000Z","path":"2018/02/28/设计一个换肤工具/","text":"从几个维度去思考 一个换肤工具应该具有的功能 是否在现有的项目基础上实现 代码层面上如何设计 一个换肤工具应该具有的功能 是否在现有的项目基础上实现 代码层面上如何设计","tags":[{"name":"工作中的点滴","slug":"工作中的点滴","permalink":"http://yoursite.com/tags/工作中的点滴/"}]},{"title":"制库Pod私有仓库","date":"2017-06-20T09:00:21.000Z","path":"2017/06/20/制库Pod私有仓库/","text":"项目中使用到pod库来解决包管理，这篇文章记录下pod库制作的一些步骤和注意事项。私有库制作官方地址:https://guides.cocoapods.org/making/private-cocoapods.html 制作pod库步骤(私有仓库) 本篇文章是基于github上创建的仓库。 第一步:环境准备 我的CocoaPods安装版本是1.2.1 cocoapods安装 sudo gem install cocoapods 第二步:创建仓库(管理你制作的pod库) 你可以在任何一个git服务器上创建一个私有仓库。下面的截图是我在github上已经创建的一个仓库SLTestSpecs 通过下面的命令添加仓库到本地 pod repo add SLTestSpecs https://github.com/lishuailibertine/SLTestSpecs.git 如果添加成功会在目录中看到添加的仓库(如下)。 第三步:制作一个pod库并上传到你建的仓库中(上面步骤建的仓库) 开始建一个仓库(作为你的pod库) 下图是我已经创建好并提交过的一个仓库SLFirstPod clone 刚创建的仓库(SLFirstPod)到本地 开始编辑podspec文件(非常重要)1, 管理着你的pod库源文件、模块、.a、.framework等的依赖关系。2, 关系到pod库能否验证并成功push到我们自己的pods仓库中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Pod::Spec.new do|s| //项目名 s.name =&apos;SLFirstPod&apos; //版本号 s.version =&apos;1.0.0&apos; //详细介绍 s.description = &quot;详细介绍&quot; //license文件的类型 s.license = &apos;MIT&apos; //简单描述 s.summary = &apos;ATest in iOS.&apos; //支持的平台及版本 s.platform = :ios, &apos;7.0&apos; //最低要求的系统版本 s.ios.deployment_target= &apos;7.0&apos; //项目的地址，只支持HTTP和HTTPS地址，不支持ssh的地址 s.homepage =&apos;https://github.com/lishuailibertine/SLFirstPod&apos; //截图 s.screenshots = &quot;www.example.com/screenshots_1&quot; //多媒体介绍地址 s.social_media_url = &apos;https://twitter.com/&lt;twitter_username&gt;&apos; //作者和邮箱 s.authors = &#123;&apos;lishuai&apos; =&gt; &apos;lishuai19@yeah.net&apos; &#125; //git仓库的https地址 s.source = &#123; :git=&gt;&apos;https://github.com/lishuailibertine/SLFirstPod.git&apos;, :tag =&gt;s.version&#125; //是否要求arc s.requires_arc = true //在这个属性中声明过的.h文件能够使用&lt;&gt;方法联想调用（这个是可选属性） s.public_header_files = &apos;UIKit/*.h&apos; //表示源文件的路径，这个路径是相对podspec文件而言的 s.source_files =&apos;AppInfo/*.*&apos; #依赖关系，该项目所依赖的其他库 s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos; //可拥有多个dependency依赖属性 s.dependency &apos;JSONKit&apos;, &apos;~&gt; 1.4&apos; //资源文件存放位置，放在Resources文件夹中 s.resource_bundles = &#123; &apos;Test5&apos; =&gt; [&apos;Test5/Assets/*.png&apos;] &#125; // 设置只依赖一个系统的library s.library = &apos;iconv&apos; // 设置依赖多个系统的library s.libraries = &apos;iconv&apos;, &apos;xml2&apos; //其他的library。 s.vendored_libraries = &quot;x.a&quot; //需要用到的frameworks，不需要加.frameworks后缀。（这个没有用到也可以不填） s.frameworks =&apos;Foundation&apos;, &apos;CoreGraphics&apos;, &apos;UIKit&apos; //本地的frameworks s.vendored_frameworks =&quot;&quot; //依赖的路径 s.preserve_paths = &apos;x.framework&apos; //依赖的库 s.frameworks = &apos;x&apos; //资源 s.resource = &quot;x.bundle&quot; //配置参数 s.xcconfig = &#123; &apos;FRAMEWORK_SEARCH_PATHS&apos; =&gt; &apos;&quot;$(SRCROOT)/x&quot;&apos; &#125; //建立名称为Info的子文件夹（虚拟路径） s.subspec &apos;Info&apos; do |ss| ss.subspec &apos;InfoSub&apos; do |sss| end endend 第四步:验证你的podspec文件 主要是验证你的文件建立的依赖关系是否正确。 pod lib lint –allow-warnings 本地podspec文件地址 2017-6-27增加 在我们需要依赖一些自己的做的pod库的时候，因为这些仓库的地址是放在我们的私有仓库下的。默认情况下我们直接去依赖，然后去校验podspec文件是有问题的。解决办法:在校验podspec文件的时候指定下我们的私有仓库地址-&gt; pod lib lint –sources =地址1,地址2 第五步:打个tag上传到我们的pod库 git add .git commit -m “描述信息”git tag 版本号 -m “描述信息”git push –tags 第六步:push我们刚才做的pod库到我们pods仓库中 pod repo push pods仓名字 –allow-warnings 本地的podspec文件路径 到此我们的pod库制作完成。 我们可以在远程自己的私有仓库中可以看到这条记录版本等信息。 本地pod search一下看是否有这个仓库 到此我们的pod库创建完毕并且上传到了我们的私有仓库中了。 其他内容 常用命令详情说明: 参考:https://guides.cocoapods.org/terminal/commands.html touch Podfile :生成pofile文件 pod install:根据podfile文件安装pod库 pod update:更新库(可以指定某个具体的pod库) pod spec create:生一个podspec文件 pod spec create xx 地址 (已有库) pod spec lint:远程校验podspec文件 pod repo add:增加私有仓库到本地 pod repo update:更新本地仓库 pod repo lint:验证仓库下所有的podspec文件 pod repo list:列出本地仓库下所有的pod库 pod lib create:创建一个模版工程 pod ipc spec:把podspec文件格式转为podspec.json 一些小技巧: 1.加快pod install/update 速度 pod install –no-repo-updatepod update –no-repo-update 注意事项 1.–use-libraries 当你遇到下面的错误：include of non-modular header inside framework module 发布的时候带上--use-libraries","tags":[{"name":"工作中的点滴","slug":"工作中的点滴","permalink":"http://yoursite.com/tags/工作中的点滴/"}]},{"title":"Universal Links集成","date":"2017-06-18T10:11:46.000Z","path":"2017/06/18/Universal-Links集成/","text":"写这篇文章的目的是记录下在项目中集成Universal Links所遇到的问题。在介绍遇到的问题之前先来说下Universal Links what’s this?官方介绍; When you support universal links, iOS users can tap a link to your website and get seamlessly redirected to your installed app without going through Safari. If your app isn’t installed, tapping a link to your website opens your website in Safari. Universal Links是苹果iOS9推出的功能。如果你的项目中支持了Universal Links，当用户安装过后，点击你的链接地址(标准的HTTP或HTTPS)不用使用safari就可以无缝的跳转到你的APP中；如果用户没有安装，那么点击你的链接地址将会在Safari中打开。 有时候我们会遇到这种需求：分享一个页面到微信，当用户在微信中打开这个分享链接的时候会有一个打开按钮，引导并告诉用户点击按钮可以跳转到对应的APP，但是有个条件就是不能借助于safari浏览器跳转。那么我们就需要用到Universal Links技术了。 项目如何支持 只需要简单几步你的项目就可以拥有这个强大的功能；1，创建apple-app-site-association文件，这个文件的内容是json格式的，但是这个文件一定不要有.json后缀；2，上传第一步创建的配置文件到你的HTTPSweb服务器。苹果提供了指定的目录:你的web服务器的根目录或者是.well-known这个目录；3，做完上面两件事接下来需要在你的xcode中配置entitlement文件，相关配置的内容可以看官方提供的介绍； 好了这就支持了！！ =.= 其实步骤是挺简单的，但是我却集成了三天多，尼玛！ 为什么我会集成三天多呢？除去让发邮件让服务端配置上传那个配置文件用了一天= .=;剩下的时间我在干嘛了：调试啊，为什么就是点击链接跳转不了。如果我们在集成Universal Links功能时出现问题是不太容易定位问题所在的。官方提供的测试地址https://search.developer.apple.com/appsearch-validation-tool/可以帮助我们检验apple-app-site-association文件路径是不是配置正确，当然还有其他的作用。这不废话吗，=。=测试中思考几种无法跳转的原因(结合大量的google):1，点击跳转的链接的域名与上一个加载的链接的域名必须不一样，也就是跨域才能让跳转生效；2，我上传在web服务器上的配置文件格式或者内容错了；3，我放到web服务器的路径错了；4，xcode中配置的entitlement的信息有问题；5,apple-app-site-association文件没有下载到手机上。一一排除：1，这个很容易检测，搞两个不同的域名进行测试就ok;2，我是完全按照官网来的应该不会出错；3，这个经过与运维人员交流并没有出现问题；4，我是一次两次再次的看这个文件也没有发现问题；5，这个apple-app-site-association文件我该怎么知道是否下载到手机了呢?况且我也不知道它下载到哪里了。 到这里我要提醒下我们在测试过程中出现跳转问题时，自己一定要抓包！抓包！抓包！这样我们如果发现在这一步出现问题就可以大概定位到问题出在哪里了，是在服务端还是在客户端。然后再进行更细致的分析问题。 我的问题出现哪里呢？就是第五个原因：文件没有下载到手机上。当APP首次安装时，我对它进行抓包发现，文件不能被下载，原因就是它的域名竟然与我放配置文件的域名不一样！为什么会出现这个问题呢？原因让自己苦笑不得，我在项目中发现两个同样的entitlement文件，而造成问题的就是其中一个配置异常域名(造成404无法下载配置文件)的文件。删除多余的异常文件重新安装，测试跳转通过。 总结一下：如果自己能及时的抓包就可以尽早的发现问题所在，在以后排查问题时，告诫自己一定要切中重点来排除定位问题所在。","tags":[{"name":"工作中的点滴","slug":"工作中的点滴","permalink":"http://yoursite.com/tags/工作中的点滴/"}]},{"title":"socket.io中的小坑","date":"2017-05-07T05:24:27.000Z","path":"2017/05/07/socket-io中的小坑/","text":"这周五应领导要求第二次去了上海电气解决技术上的问题。周四接到通知说是电气那边同事遇到个问题：前端项目中用到socket.io定时请求数据时导致后台服务挂掉了。 自己平时项目中也没用到过socket.io网络组件去处理数据请求。心想说不定可能是其他问题导致，还是先去看看再说。早上一到项目组我就赶紧看了下问题。他们里面的业务场景是这样：用长连接定时2s去后台拿数据，如果服务端没响应就定时10s再去请求数据。本来想着是不是代码里频繁建立连接导致的后台服务挂掉了呢，通过用socket.io的监听方法并没发现程序中重新去建立连接的通知。但是后台的工程师通过日志说明前端确实是一直在发get,post，并不是建立一个socket通道执行请求响应的。 通过查阅资料发现对于WebSocket来说它必须依赖HTTP协议进行一次握手握手成功后,数据就直接从TCP 通道传输,与HTTP无关了,在进行http握手以后它会根据配置参数可以自动升级成websocket进行双向通信。 项目中所表现出来的问题就是进行请求是并没有升级成websocket通信方式，还是进行以http的方式进行polling,通过配置socket.io中的日志参数打印日志也证实了这一点。那么为什么会升级失败呢，原因就是再进行第一步http握手时失败了，项目中用是https的方式进行请求的，但是因为用的是自签名的证书导致握手失败，这才导致socket.io以老的polling方式进行请求的。那么定位到问题所在，通过更改socket.io组件参数允许自签名证书进行请求就解决了这个问题。","tags":[{"name":"工作中的点滴","slug":"工作中的点滴","permalink":"http://yoursite.com/tags/工作中的点滴/"}]},{"title":"界面流畅优化","date":"2017-03-08T08:10:49.000Z","path":"2017/03/08/界面流畅优化/","text":"App的开发中,界面的流畅度是非常重要的。它决定到用户对产品体验的好感。在IOS开发中容易出现界面体验不好的地方是tableView列表。你是否想过为什么自己写的列表那么不流畅？是什么影响了它的流畅度？当你的APP启动渲染界面时需要经过大量的计算尤其是比较复杂的列表。这样的过程很耗时，那么就会引起界面不流畅。 视图从创建到渲染到屏幕显示的过程大致可以通过下面的时序描述出来。 注:以上的时序是我通过这篇连接总结出来的，如果有错误欢迎指正。","tags":[]},{"title":"Swift学习小知识点-构造过程","date":"2017-02-27T07:10:02.000Z","path":"2017/02/27/swift学习小知识点-一/","text":"上周花了时间去学习了swift，虽然自己是搞IOS开发但是之前并没有接触过这门新生语言。通过文章总结一下自己学习到的重要知识点，算是回顾一下。 构造过程定义:构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例可用前必须执行这个过程，具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作 两段构造过程： 下图中是存在一层继承关系的构造调用过程 构造器的自动继承: 总结一点:如果子类没有定义指定构造器或者把父类的所有指定构造器都实现了，那么子类就会继承父类所有的便利构造器","tags":[{"name":"小知识","slug":"小知识","permalink":"http://yoursite.com/tags/小知识/"},{"name":"swift","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"xcode中的一些编译选项介绍","date":"2016-12-29T10:58:23.000Z","path":"2016/12/29/xcode中的一些编译选项介绍/","text":"整理下xcode中一些编译选项有关内容。官方介绍地址 https://developer.apple.com/legacy/library/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/0-Introduction/introduction.html Generate Debug Symbols 这个选项改为NO的话编译出来的可执行文件会小很多。但是代码中设置的有断点的话，断点不会起作用。 Write Link Map File 功能介绍: 通过配置参数，输出项目可执行文件。根据可执行文件可以分析出：文件构成元素、大小等。 如何配置：XCode -&gt; Project -&gt; Build Settings -&gt; 搜map -&gt; 把Write Link Map File选项设为yes，并指定好linkMap的存储位置 2017-7-11 新增 Strip相关 Deployment Postprocessing 功能介绍：strip所有选项的总开关，如果选NO，以下选项均无效 如何配置：省略 Strip Debug Symbols During Copy 功能介绍：文件拷贝编译阶段时是否进行strip，你的工程中有CopyFilesBuildPhase才有意义 如何配置：省略 Strip Linked Product 功能介绍：这个选项才对最后生成的二进制文件进行strip 如何配置：省略 Strip Style 功能介绍：all，non-global，debugging strip程度依次降低：all一般用于最后生成.app的工程；non-global用于bundle和framework，debugging一般都可以。虽然all是strip最多的选项，但是选择错误会导致strip失败 如何配置：省略 Dead Code Stripping 功能介绍：用于删除对象文件中不需要加载的符号，减小二进制文件大小 如何配置：省略 2018-3-8 新增Runpath Search Paths 功能介绍：@executable_path 这个变量表示可执行程序所在的目录 Search Paths $(inherited): 一个项目里面有多个target，使用到了同一个库(Library或Framework)那么为了方便我们可以在target添加继承参数继承的优先级：1、Platform defaults2、Project file (描述举例用这个优先级，比较常用)3、xcconfig file for the Project file4、Target5、xcconfig file for the Target recursive:遍历该目录,会遍历该目录下的所有子目录的库文件。 non-recursive:不遍历该目录。","tags":[{"name":"小知识","slug":"小知识","permalink":"http://yoursite.com/tags/小知识/"}]},{"title":"HTTPS单向双向认证","date":"2016-12-23T10:40:14.000Z","path":"2016/12/23/HTTPS单向双向认证/","text":"HTTPS单向认证双向认证自己原来认识很模糊，今天搜索了资料结合UML图记录一下它的工作流程。 HTTPS单向认证流程: HTTPS双向认证流程:","tags":[{"name":"小知识","slug":"小知识","permalink":"http://yoursite.com/tags/小知识/"}]},{"title":"网络请求HTTPS相关","date":"2016-12-21T10:33:40.000Z","path":"2016/12/21/网络请求HTTPS相关/","text":"昨天晚上在测试认证服务的时候暂时解决了一个问题,数据服务用的请求是http,但是认证请求是https。苹果本来就推荐用https来与服务器连接。现在是为了满足开发的需要通过改配置文件来真对请求是http的场景。 问题：认证的方式是通过https://ip:port方式发请求的，在运行中出现crash,原因是Error Domain=NSURLErrorDomain Code=-1202 “The certificate for this server is invalid. You might be connecting to a server that is pretending to be “xxx.xxx.xxx.xxx” which could put your confidential information at risk.”。 通过查资料通过以上方式暂时解决了这个问题(我发的请求采用的NSURLSession请求，通过设置代理)。","tags":[{"name":"项目相关内容","slug":"项目相关内容","permalink":"http://yoursite.com/tags/项目相关内容/"}]},{"title":"项目相关内容之网络框架","date":"2016-12-20T10:11:33.000Z","path":"2016/12/20/项目相关内容之网络框架/","text":"马上就要过年了，项目差不多快结束了，这几个月在工作中遇到了很多问题，同时这些问题也磨砺了我。这个项目是一个关于网络请求的框架，里面有很多设计元素，也有很多自己平时需要多注意的地方，感觉自己有必要记录下来。通过这篇文章一方面回顾一下框架内容,再一个有些缺陷可以在这时候清晰的暴露出来。 框架大体上分为认证模块与数据服务模块。认证模块中的一些策略是这个模块的主要部分;数据服务中会有一些编程的思想以及一些设计元素，这些内容会影响着框架的健壮性、扩展性等诸多方面。 认证模块 数据服务模块 框架有几方面的特点： 框架整体在编写之前通过面向接口设计(保持平台一致性、更容易理解系统子模块之间的业务关系)。 数据结构方面由常见的key-value键值对设计为只有value的结构模型(节省流量带宽)。 数据都通过gzip压缩处理。 采用系统库进行编码开发(可维护性强、减小包的大小)。 在安全性方面认证流程采用https的形式请求资源服务。 真对数据请求接口会同时有n个连接去请求服务器，connectManage(连接管理)会采用同步的方式，以此来减小服务器的压力(n的大小通过task队列管理)。 框架其它缺陷: 数据服务请求通过http的方式进行，请求中携带的token或会话id等信息是明文的。(设计缺陷) 编码过程中用到很多递归锁有些地方存在滥用的情况。(编码缺陷) 框架在长时间运行过程中会有一些内存没释放，虽然通过性能工具instrument分析过但是还会出现。(性能) 认证模块 认证工作流在认证流程中几个管理类中会遇到一些策略和技术点:tokenManage和serverManage中的容器安全性(针对不同线程之间的出现的临界点)、策略管理中对认证返回的服务器列表进行测速处理. 数据服务模块 数据服务模块工作流","tags":[{"name":"项目相关内容","slug":"项目相关内容","permalink":"http://yoursite.com/tags/项目相关内容/"}]},{"title":"dispatch_sync使用中的问题","date":"2016-11-30T09:50:40.000Z","path":"2016/11/30/dispatch-sync使用中的问题/","text":"昨天在测试自己写的关于网络请求SDK时候遇到了一个奇葩的问题,具体场景就先不说了，直接回顾下问题发生的原因。 在SDK请求任务时我都会把任务放在单独的线程中，SDK中我只new了这么一个线程暂且叫它SDK线程。 问题来了: 当我发请求任务给SDK线程过程中，请求超时的时候再次发请求,我发现SDK线程不会执行我发请求的这个任务了，也是线程退出或者阻塞了。经过测试发现线程并没有退出而是阻塞了。 具体的原因: SDK线程被阻塞让我想到的最直接的原因就是里面的用的锁发生死锁导致的。找到是因为这个导致的我就好找代码出错的地方了。在这里我把代码贴出来来看一下。问题就出现在使用dispatch的地方。因为我用的队列是一个串行队列，当在使用dispatch_sync的时候一般是不会发生什么问题的，但是当在代码中嵌套使用它的时候就会出现死锁的情况。回到上面描述的问题上，当请求超时的时候我会使用遍历队列这个方法检查是否超时而且在block中我还使用了超时时需要调用释放资源这个方法，这时就会产生嵌套的情况(请求超时释放资源这个任务会等待遍历队列任务结束后才会执行但是遍历队列这个任务也在等待释放资源这个任务)。 解决办法: 我当时解决办法就是上面代码中看到的把释放资源这个改为用dispatch_async执行任务，那么锁就会直接被释放给遍历队列这个任务，也不影响释放block的操作。 有没有好的办法避免这种嵌套使用的dispatch_sync或者打印一些信息给开发人员。那么就会定位问题所在。 下面的方法是我在网上找到的解决方案，我感觉挺不错的。这段代码通过信号量和dispatch_async模拟dispatch_sync。我们可以直接拿这段代码当作dispatch_sync来使用。用这段代码除了这个用处当发生死锁或者同步的情况时可以打印信息，并且可以设置死锁或者同步了多少时间才打印信息。 注:以上代码出自http://www.dreamingwish.com/article/sync-task-safely.html这个站点。","tags":[{"name":"工作中的点滴","slug":"工作中的点滴","permalink":"http://yoursite.com/tags/工作中的点滴/"}]},{"title":"Clang、LLVM知识记录","date":"2016-11-20T06:20:36.000Z","path":"2016/11/20/Clang、LLVM知识记录/","text":"上午的时候看了趣直播中孙源大神讲的Apple编译器相关知识，现在我把他的ppt上面的相关内容记录下来，没事的时候好好滴的认识学习下(有些图片没有贴上,空闲时间再整理)。 Apple编译器Clang-LLVN架构初识 你的源码是如何一步步成为可执行文件的? 我们能用Clang做什么有意思的事情?Apple编译器Clang-LLVN架构初识 LLVM - Low Level Virtual Machine (编译器后端) Clang - C Language Family Frontend For LLVM (编译器前端)###GCC用的好好的,Apple为啥要自己搞一套？ GCC的Objective-C Frontend不给力 GCC插件、工具、IDE的支持薄弱 GCC编译效率和性能 Apple收回对工具链的控制(lldb,lld,swift…)Three-Phase 编译器架构source-&gt;Frontend、Optimizer、Backend-&gt;machinecode 源码、前端、优化、后端、机器码 Clang+LLVM代码规模 Total 400w c++ 235###Swift Frontend代码规模 c++ 43w你的源码是如何一步步成为可执行文件的? 当我们点击run按钮的时候，执行了一大串的脚本(配置xcode上的一些参数)1/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctolchain/usr/bin/clang -x objective-c -fobjc-arc ...... main.m -o main.o Clang命令 Clang在概念上是编译器前端，同时，在命令中也作为一个黑盒的Driver(驱动) 封装了编译管线、前端命令、LLVM命令、Toolchain命令等，一个Clang走天下 方便从gcc迁移过来拆解编译过程123456789main.m#import &lt;Foundation/Foundation.h&gt;int main()&#123; @autoreleasepool&#123; id obj = [NSObject new]; NSLog(@&quot;hello world: %@&quot;,obj); &#125; return 0;&#125; Preprocess - 预处理 import 头文件 macro 展开 处理#打头的预处理指令，如#if 命令1$clang -E main.m 注意：pch文件正确使用 命令12//-fmodules 默认会把库打成module的形式$clang -E -fmodules main.m 12&gt;@import Foundation;其它不变... Lexical Analysis -词法分析 词法分析，也作lex或者Tokenization 将预处理过的代码文本转化成Token流 不校验语义 命令123//-fsyntax -only:解到语法层面 -Xclang -dump:透传给前端的工具搞成token流$clang -fmodules -fsyntax -only -Xclang -dump -tokens main.m 缺少图片 Semantic Analysis - 语法分析 语法分析，在Clang中由Parse和sema两个模块配合完成 验证语法是否正确 根据当前语言的语法，生成语意节点，并将所有节点组成抽象语法树(AST) 命令1$clang -fmodules -fsyntax -only -Xclang -ast -dump -tokens main.m 缺少图额外的步骤Static Analysis -静态分析 通过语法树进行代码静态分析，找出非语法性错误 模拟代码执行路径，分析出control-flow graph (CFG) 预置了常用Checker CodeGen -IR代码生成 CodeGen 负责将语法树从顶至下遍历，翻译成LLVM IR LLVM IR是Frontend的输出，也是LLVM Backend的输入，前后端的桥接语言 与Objective-C Runtime 桥接 4(1). 与Objective-C Runtime的桥接 Class/Meta Class/Protocol/Category内存结构生成，并存放在指定section中(如Class:_DATA,_objc_classrefs) Method/Ivar/Property内存结构生成 组成method_list/ivar_list/property_list并填入Class Non-Fragile ABI:为每个Ivar合成OBJC_IVAR_$_偏移值常量 存取Ivar的语句(_ivar =123;int a= _ivar;)转写成base+OBJC_IVAR_$_的形式 将语法树中的ObjCMessageExpr翻译成相应版本的objc_msgSend,对super关键字的调用翻译成objc_msgSendSuper 根据修饰符strong/weak/copy/atomic合成@property自动实现的setter/getter 处理@synthesize 生成block_layout的数据结构 变量的capture(_block/_weak) 生成_block_invoke函数 ARC: 分析对象引用关系，将objc_storeStrong/objc_storeWeak等ARC代码插入 将ObjcAutoreleasePoolStmt转译成objc_autoreleasePoolPush/Pop 实现自动调用[super dealloc] 为每个拥有ivar的Class合成.cxx_destructor方法类自动释放类的成员变量，代替MRC时代的”self.xxx=nil” 命令12// -S $clang -S -fobjc-arc -emit-llvm main.m -o main.ll Optimize -优化IR 命令1$clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll LLVM Bitcode -生成字节码1&gt;$clang -emit-llvm -c main.m -o main.bc Assemble - 生成Target相关汇编1&gt;$clang -S -fobjc-arc main.m -o main.s Assemble - 生成Target相关Object(Mach-O)1&gt;$clang -fmodules -c main.m -o main.o Link生成Executable12&gt;$clang main.m -o main$./main 我们能用Clang做什么有意思的事情? LibClang LibTooling ClangPlugin LibClang 1、C API 来访问Clang的上层能力，如获取Tokens、遍历语法树、代码补全、获取诊断信息2、API稳定，不受Clang源码更新影响3、只有上层的语法树访问不能获取到全部信息 LibClang使用 1、使用原始C API2、脚本语言:使用官方提供的python binding 或开源的node-js/ruby binding3、Objective-C:开源库ClangKit LibTooling 1、对语法树有完全的控制权2、可作为一个standalone命令单独的使用，如clang-format3、需要使用c++且对Clang源码熟悉 ClangPlugin 1、对语法树有完全的控制权2、作为插件注入到编译流程中，可以影响build和决定编译过程3、需要使用c++且对Clang源码熟悉 http://clang.llvm.org/docs/index.htmlhttp://blog.llvm.org/https://www.objc.io/issues/6-build-tools/compilerhttp://llvm.org/docs/tutorial/index.htmlhttps://github.com/loarabia/Clang-tutorialhttp://lowlevelbits.org/getting-started-with-llvm/clang-on-os-x/http://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-i-introduction/http://szelei.me/code-generator/“&lt;&lt;Getting Started with LLVM Core Libraries&gt;&gt;&lt;&lt;LLVM Cookbook&gt;&gt;&quot;","tags":[{"name":"编译器","slug":"编译器","permalink":"http://yoursite.com/tags/编译器/"}]},{"title":"工作中小问题","date":"2016-11-14T01:20:36.000Z","path":"2016/11/14/工作中小问题/","text":"上周五在根据网络服务获取数据的时候，本来上午可以请求回来的数据突然就下午就解析不到数据了。今天早上的时候我想还是把这个问题记下来。 #问题发生的精确位置 通过xcode断点在渲染html页面之前，这时候发现当程序走到断点的位置时程序已经在控制台打印堆栈了。这么一看就是说问题发生在子线程中了，并且也有输出问题的原因Unable to convert data to string around character 79。但是即使有输出原因我也不能立马定位它发生的位置。好在整个SDK除了网络请求的回调是系统又开的线程，其他就一个子线程处理任务(其实如果我事先能给SDK处理任务的线程定义个名字的话就会很快定位问题发生的位置),通过断点终于定位出原来在解析数据的时候问题就发生了，也就是在下面的回调方法中:123456httpManage.requestComplication=^(NSData * data,NSURLResponse * urlresponse,NSError * error)&#123;//出错的精确位置NSDictionary *jsonDic = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:&amp;error2];&#125; #问题产生的原因 找到出错的位置后我想这个方法是系统提供的给我们处理json的怎么会解析失败了呢，原来怎么可以解析呢(只能说自己太菜了)？ #问题解决过程根据控制台的信息提示找到原来是在处理中文的时候转换不成功。问了下后台的同志，他们在处理中文的时候是通过gbk编码过的。这才知道是编码解码的问题。下面是转码的方法:1234//转换成gbkNSStringEncoding gbkEncoding = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);//NSString *result =[[ NSString alloc] initWithData:data encoding:gbkEncoding]; #回顾: 发生这次问题可以看到自己编码方式有待提高，一个通过控制台信息就可以定位的问题我却解决了好长时间。 #遗留问题 编码方法中CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);传入的参数为什么不能是kCFStringEncodingGB_2312_80,这两个参数有什么区别联系。现在只知道kCFStringEncodingGB_18030_2000是kCFStringEncodingGB_2312_80的扩展。","tags":[{"name":"工作中的点滴","slug":"工作中的点滴","permalink":"http://yoursite.com/tags/工作中的点滴/"}]},{"title":"记录一下hexo的安装","date":"2016-11-05T06:12:24.000Z","path":"2016/11/05/记录一下hexo的安装/","text":"前几天刚开通了blog,趁着现在还记起来步骤把它纪录下来。差点忘了说，我安装的平台是在mac上进行的。 开始 安装node.js 安装hexo hexo初始化 安装依赖和插件 同步hexo到github 主题更换 一些配置项修改 换电脑了怎么办?2017/5/8增加 安装node.js 使用下面的命令(直接在终端输入):1$ brew install node 安装hexo 这里我直接用的淘宝NPM镜像1$ npm install -g cnpm --registry=https://registry.npm.taobao.org hexo初始化 安装hexo完毕后，在自己的用户目录下建立一个文件夹，名字可以随便的起。在终端:12$ cd 建立的文件夹下$ hexo init 安装依赖和插件 终端执行12$ npm install$ npm install hexo-deployer-git --save 这样我们的本地环境就搭建好了，我们测试预览一下，在终端输入:1$ hexo server 在浏览器中输入http://localhost:4000/。正常的情况下就可以看到blog页面了。如果想在blog中插入图片的话，更改_config.yml中的post_asset_folder: true;然后在根目录下执行:1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 这样就可以看到在根目录的source/_posts下创建了一个跟md文件同名的文件夹如下图所示： 在blog中使用图片的时候就在这个文件下建立需要的图片，在.md文件中引用即可,引用方式:1![图片](文件夹名字/xx.png)' 同步hexo到github 本地安装完毕，接下来就要在github上建立一个仓库用来存储我们日志的静态文件等。新建一个仓库取名为xx.github.io。这里切记’.github.io’不能写错。创建仓库完毕。 在本地_config.yml中更改 delop项：123type: gitrepository: https://github.com/xx/xx.github.io.gitbranch: master 使用组合命令同步到github1$ hexo d -g 在浏览器中输入’http://xx.github.io&#39;。看一下是否同步成功。至此blog的搭建工作已经差不多了。 主题更换 可以看到默认的blog的出题有点丑，这里我用的是基于hexo的yilia主题。12$ cd 到themes文件夹下$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia Clone完毕之后，更改_config.yml配置中的theme: yilia。执行:1$ hexo d- g 这样我们就完成了默认主题的更换。在浏览器中输入’http://xx.github.io&#39;。看一下主题是否更换成功。 一些配置项修改可以参考这里 换电脑了怎么办?2017/5/8增加可以依次执行下面的命令:123456ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"brew install nodesudo npm install hexo -g 全局hexonpm installnpm install hexo-deployer-gitnpm install https://github.com/CodeFalling/hexo-asset-image --save 如果在执行hexo g -d 时遇到{ Error: Cannot find module &#39;./build/Release/DTraceProviderBindings’错误可以用下面的命令尝试解决:12345npm install hexo --no-optionalif it doesn't worktry$ npm uninstall hexo-cli -g$ npm install hexo-cli -g","tags":[]},{"title":"开启写博客","date":"2016-11-01T04:05:14.000Z","path":"2016/11/01/开启写博客/","text":"","tags":[]}]